<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
    <title>Captured Mouse Events</title>
    <script class="remove" src="captured-mouse-events.js" type="text/javascript"></script>
    <script src="https://www.w3.org/Tools/respec/respec-w3c" class="remove"></script>
  </head>
  <body>
    <section id="abstract">
      <h2>Abstract</h2>
      <p>
        This document specifies a mechanism for exposing to a screen-capturing application mouse
        events which occur over a captured [=display surface=].
      </p>
    </section>
    <section id="sotd"></section>
    <section id="conformance"></section>
    <section id="background">
      <h2>Background</h2>
      <p>
        Web applications can use {{MediaDevices/getDisplayMedia()}} to capture any [=display
        surface=] - <a data-cite="screen-capture/#dfn-browser">tabs</a>,
        <a data-cite="screen-capture/#dfn-window">windows</a> or
        <a data-cite="screen-capture/#dfn-monitor">screens</a>. When they do, they can also specify
        the <a data-cite="SCREEN-CAPTURE#dfn-cursor">cursor</a> constraint to control whether the
        cursor's pixels are captured or not.
      </p>
      <p>
        But what if the application wishes to programmatically observe the location of the cursor?
        That can be done by scanning each frame and employing heuristics to detect the cursor. But
        that's neither simple, nor efficient, nor robust.
      </p>
      <p>
        A mechanism for exposing mouse coordinates over a captured surface to a capturing
        application is desirable.
      </p>
    </section>
    <section id="use-cases">
      <h2>Use cases</h2>
      <section id="use-case-1">
        <h3>Use case #1: Cursor enhancement</h3>
        <p>
          During video-conferencing calls, Web applications on the receiving side can use our
          mechanism to highlight, enhance or outright replace the cursor. This can be done without
          making such distracting adjustments on the capturing side, where the presenter might not
          need such aids.
        </p>
        <p>This same can be done when recording an instructional video.</p>
      </section>
      <section id="use-case-2">
        <h3>Use case #2: Efficiency enhancements during RTC</h3>
        <p>
          Captured frames are often encoded and then transmitted remotely. Updates to the cursor
          location require a new frame to be encoded and transmitted, costing CPU, power and
          bandwidth. In theory, these costs could be minimized by efficient encoding; in practice,
          the costs are non-negligible - the entire image needs to be scanned for changes, and there
          is per-frame IPC overhead which multiplies with the max framerate.
        </p>
        <p>
          The <a data-cite="screen-capture/#dfn-cursor">cursor constraint</a>
          can be used to omit the cursor from the captured frames.
          If mouse coordinates were known to the encoding application, it could transmit these
          coordinates to the receiving application (on another device). The receiver could then
          redraw a cursor on the other side. (Note that, depending on the decoder, this is likely
          cheaper than decoding a whole new frame.) Non-trivial complexity would be added, but the
          gains to CPU, power and bandwidth on both sides might justify it.
        </p>
      </section>
    </section>
    <section id="examples">
      <h2>Examples</h2>
      <p>
        In the basic example below, a {{CaptureController}} is passed to
        {{MediaDevices/getDisplayMedia()}}. An event handler is set on that object in order to
        receive {{CapturedMouseEvent}}s with the mouse coordinates over the captured surface.
      </p>
      <pre class="example highlight">
        try {
          const controller = new CaptureController();
          controller.oncapturedmousechange = (event) => {
            console.log(`Mouse coordinates: x=${event.surfaceX}, y=${event.surfaceY}`);
          };
          let mediaStream = await navigator.mediaDevices.getDisplayMedia({ controller });
        } catch (e) {
          console.log(`Unable to acquire screen capture: ${e}`);
        }
      </pre>
      <p>
        In the following example, the
        <a data-cite="screen-capture/#dfn-cursor">cursor constraint</a> is used to omit the cursor
        from the captured display surface. The mouse coordinates are transmitted via a
        <a data-cite="webrtc/#rtcdatachannel">RTCDataChannel</a> to the receiving application, which
        can then redraw the cursor.
      </p>
      <pre class="example highlight">
        // An peer-to-peer connection is established and a data channel created for
        // transmitting the mouse events.
        const configuration = {iceServers: [{urls: 'stun:stun.example.org'}]};
        const pc = new RTCPeerConnection(configuration);
        const channel = pc.createDataChannel('mouse-events', {negotiated: true, id: 0});

        // On the capturing side, the capture session is initialized with the mouse
        // cursor ommitted from the captured surface. The mouse coordinates are
        // transmitted via the data channel.
        const controller = new CaptureController();
        controller.oncapturedmousechange = (event) => {
          channel.send(JSON.stringify({x: event.surfaceX, y: event.surfaceY}));
        };
        const mediaStream = await navigator.mediaDevices.getDisplayMedia({
          video: { cursor: "never" },
          controller: controller,
        });
        pc.addTrack(mediaStream.getVideoTracks()[0], mediaStream);
        ...

        // On the receiving side, the remote stream is rendered in a video and the
        // coordinates received from the data channel are used to redraw the cursor.
        const remoteView = document.getElementById('my-video-element');
        channel.onmessage = ({data}) => redrawCursor(removeView, JSON.parse(data));
        pc.ontrack = ({track, streams}) => {
          track.onunmute = () => {
            if (remoteView.srcObject) return;
            remoteView.srcObject = streams[0];
          };
        };
        ...
      </pre>
    </section>
    <section id="captured-mouse-change-event">
      <h2>CapturedMouseEvent interface</h2>
      <p>
        We define a new event type, {{CapturedMouseEvent}}. This is modelled after {{MouseEvent}}
        from [[UIEVENTS]], but exposes less information. Whereas {{MouseEvent}} exposes to an
        application the user's interaction with the application itself, and is therefore
        straightforward security-wise, {{CapturedMouseEvent}} exposes to an application the user's
        interaction with another application, or even with the operating system itself, calling for
        more scrutiny in which information may safely be exposed. See section
        <a href="#privacy-considerations"></a> for more details on this topic.
      </p>
      <pre class="idl">
        [Exposed=Window]
        interface CapturedMouseEvent : Event {
          constructor(DOMString type, optional CapturedMouseEventInit eventInitDict = {});
          readonly attribute long surfaceX;
          readonly attribute long surfaceY;
        };
      </pre>
      <dl data-link-for="CapturedMouseEvent" data-dfn-for="CapturedMouseEvent">
        <dt><dfn constructor>constructor()</dfn></dt>
        <dd>
          <p>Constructs a new {{CapturedMouseEvent}}.</p>
          <p>The arguments are passed as is to {{Event}}'s constructor.</p>
          <p>
            If any of {{CapturedMouseEventInit.surfaceX}} or {{CapturedMouseEventInit.surfaceY}} is
            negative, and they are not both equal to -1, then the constructor
            <a data-cite="WEBIDL#dfn-throw">throws</a> a
            <a data-cite="WEBIDL#exceptiondef-rangeerror">RangeError</a>
            exception.
          </p>
        </dd>

        <dt><dfn attribute>surfaceX</dfn></dt>
        <dd>
          <p>
            The horizontal coordinate at which the event occurred relative to the origin of the
            captured [=display surface=].
          </p>
          <p>
            The only legal negative value is -1. A combination of {{CapturedMouseEvent/surfaceX}}
            and {{CapturedMouseEvent/surfaceY}} both being set to -1 indicates that the mouse cursor
            is not over the captured surface.
          </p>
        </dd>
        <dt><dfn attribute>surfaceY</dfn></dt>
        <dd>
          <p>
            The vertical coordinate at which the event occurred relative to the origin of the
            captured [=display surface=].
          </p>
          <p>
            The only legal negative value is -1. A combination of {{CapturedMouseEvent/surfaceX}}
            and {{CapturedMouseEvent/surfaceY}} both being set to -1 indicates that the mouse cursor
            is not over the captured surface.
          </p>
        </dd>
      </dl>
    </section>
    <section id="captured-mouse-change-event-init">
      <h2>CapturedMouseEventInit dictionary</h2>
      <pre class="idl">
        dictionary CapturedMouseEventInit : EventInit {
          long surfaceX = -1;
          long surfaceY = -1;
        };
      </pre>
      <dl data-link-for="CapturedMouseEventInit" data-dfn-for="CapturedMouseEventInit">
        <dt><dfn dict-member>surfaceX</dfn></dt>
        <dd>
          <p>
            Initializes the {{CapturedMouseEvent/surfaceX}} attribute of the {{CapturedMouseEvent}}
            object to the desired horizontal relative position of the mouse pointer on the user's
            screen.
          </p>
        </dd>
        <dt><dfn dict-member>surfaceY</dfn></dt>
        <dd>
          <p>
            Initializes the {{CapturedMouseEvent/surfaceY}} attribute of the {{CapturedMouseEvent}}
            object to the desired vertical relative position of the mouse pointer on the user's
            screen.
          </p>
        </dd>
      </dl>
    </section>
    <section id="capture-controller-extensions">
      <h2>CaptureController Extensions</h2>
      <pre class="idl">
        partial interface CaptureController {
          attribute EventHandler oncapturedmousechange;
        };
      </pre>
      <dl data-link-for="CaptureController" data-dfn-for="CaptureController">
        <dt>
          <dfn>oncapturedmousechange</dfn>
        </dt>
        <dd>
          <p>
            We extend {{CaptureController}} with {{CaptureController/oncapturedmousechange}}, an
            {{EventHandler}} for events of type {{CapturedMouseEvent}}.
          </p>
          <p>
            User agents MAY limit the frequency with which events are fired. This can be achieved by
            briefly buffering events, then skipping the events for some states and reporting only the
            latest one. User agents SHOULD only buffer for very short periods of time.
          </p>
          <p>
            Events MUST NOT be fired after the original video track and all its clones have been
            stopped.
          </p>
        </dd>
      </dl>
    </section>
    <section class="informative">
      <h2>Security Considerations</h2>
      <p>
        This specification only exposes new information about the mouse of a
        <a data-cite="screen-capture/#dfn-capture-session">capture-session</a> and has no known
        security impacts.
      </p>
    </section>
    <section class="informative">
      <h2>Privacy Considerations</h2>
      <p>
        This specification only exposes mouse events from a
        <a data-cite="screen-capture/#dfn-capture-session">capture-session</a>. Such a session is
        started by a call to {{MediaDevices/getDisplayMedia()}} which accepts a `CaptureController`
        as an argument. The controller is the object to which mouse events are dispatched.
        Consequently, the way this new information is exposed is indentical to
        {{MediaDevices/getDisplayMedia()}}. In particular, the restriction to launch the capture are
        the same, the information is limited to the document that started the capture, and the
        information is no longer exposed after capture ends.
      </p>
      <p>
        Mouse events do not contain any personally-identifiable information. Platforms may expose
        different kind of events (e.g. special gestures only on mobile platforms) but current
        version only exposes mouse coordinates within the captured surface, which is platform
        independent. One could potentially infer sensitive information on the person performing the
        screen capture (e.g. mouse speed, tremor, no move at all) but as explained below mouse
        coordinates can actually already be obtained from video frames.
      </p>
      <p>
        This specification exposes mouse coordinates when the mouse is within the captured surface,
        or notifies when the mouse leaves the captured surface. This can be determined by scanning
        the captured video frames and employing heuristics to detect the position of the cursor, or
        when it disappears. However, this approach requires extra code and calculation for web
        developers and is neither simple, nor efficient, nor robust.
      </p>
      <p>
        Incidentally, note that the
        <a data-cite="screen-capture/#dfn-cursor">cursor constraint</a> is completely under control
        of the document that started the capture and does not affect how
        {{MediaDevices/getDisplayMedia()}}'s permission request is presented to the user. So for
        safety analysis we only need to consider the case when {{CursorCaptureConstraint}} is set to
        `"always"`.
      </p>
      <p>
        When implementing this feature, one must be careful to dispatch mouse coordinates only when
        the cursor is drawn in the captured surface, and to notify mouse departure from the surface
        only when the cursor disappears. Be aware of subtle cases such as a captured window or tab
        switching between inactive and active states, or reordering of the window stack using
        keyboard shortcuts.
      </p>
    </section>
  </body>
</html>
